\section{Pgmemcache}
\label{sec:pgmemcache}

\href{http://memcached.org/}{Memcached}~--- программное обеспечение, реализующее сервис кэширования данных в оперативной памяти на основе хеш-таблицы. С помощью клиентской библиотеки позволяет кэшировать данные в оперативной памяти множества доступных серверов. Распределение реализуется путём сегментирования данных по значению хэша ключа по аналогии с сокетами хэш-таблицы. Клиентская библиотека, используя ключ данных, вычисляет хэш и использует его для выбора соответствующего сервера. Ситуация сбоя сервера трактуется как промах кэша, что позволяет повышать отказоустойчивость комплекса за счет наращивания количества memcached серверов и возможности производить их горячую замену.

\href{http://pgfoundry.org/projects/pgmemcache/}{Pgmemcache}~--- это PostgreSQL API библиотека на основе libmemcached для взаимодействия с memcached. С помощью данной библиотеки PostgreSQL может записывать, считывать, искать и удалять данные из memcached.


\subsection{Установка}

Поскольку Pgmemcache идет как модуль, то потребуется PostgreSQL с PGXS (если уже не установлен, поскольку в сборках для Linux присутствует PGXS). Также потребуется memcached и libmemcached библиотека версии не ниже 0.38. После скачивания и распаковки исходников достаточно выполнить в консоли:

\begin{lstlisting}[language=Bash,label=lst:pgcache1,caption=Установка из исходников]
$ make
$ sudo make install
\end{lstlisting}


\subsection{Настройка}

После успешной установки Pgmemcache потребуется добавить во все базы данных (на которых вы хотите использовать Pgmemcache) функции для работы с этой библиотекой:

\begin{lstlisting}[language=SQL,label=lst:pgcache5,caption=Настройка]
% psql [mydbname] [pguser]
[mydbname]=# CREATE EXTENSION pgmemcache;
\end{lstlisting}

Теперь можно добавлять сервера memcached через \lstinline!memcache_server_add! и работать с кэшем. Но есть одно но. Все сервера memcached придется задавать при каждом новом подключении к PostgreSQL. Это ограничение можно обойти, если настроить параметры в \lstinline!postgresql.conf! файле:

\begin{itemize}
  \item Добавить \lstinline!pgmemcache! в \lstinline!shared_preload_libraries! (автозагрузка библиотеки pgmemcache во время старта PostgreSQL);
  \item Добавить \lstinline!pgmemcache! в \lstinline!custom_variable_classes! (устанавливаем переменную для pgmemcache);
  \item Создаем \lstinline!pgmemcache.default_servers!, указав в формате <<host:port>> (port - опционально) через запятую. Например:

\begin{lstlisting}[label=lst:pgcache6,caption=Настройка default\_servers]
pgmemcache.default_servers = '127.0.0.1, 192.168.0.20:11211' # подключили два сервера memcached
\end{lstlisting}

\item Также можем настроить работу самой библиотеки pgmemcache через \lstinline!pgmemcache.default_behavior!. Настройки соответствуют настройкам libmemcached. Например:

\begin{lstlisting}[label=lst:pgcache7,caption=Настройка pgmemcache]
pgmemcache.default_behavior='BINARY_PROTOCOL:1'
\end{lstlisting}

\end{itemize}

Теперь не требуется при подключении к PostgreSQL указывать сервера memcached.


\subsection{Проверка}

После успешной установки и настройки pgmemcache становится доступен список команд для работы с memcached серверами.

\begin{table}[h]
\caption{Список команд pgmemcache}
\label{tabular:pgmemcache1}
\begin{tabular}{| >{\raggedright\scriptsize}p{7cm}| >{\scriptsize}p{7cm} |}
\hline
Команда & Описание\\
\hline
memcache\_server\_add('hostname:port'::TEXT)

memcache\_server\_add('hostname'::TEXT)
&
Добавляет memcached сервер в список доступных серверов. Если порт не указан, по умолчанию используется 11211.\\

\hline

memcache\_add(key::TEXT, value::TEXT, expire::TIMESTAMPTZ)

memcache\_add(key::TEXT, value::TEXT, expire::INTERVAL)

memcache\_add(key::TEXT, value::TEXT)
&
Добавляет ключ в кэш, если ключ не существует.\\

\hline

newval = memcache\_decr(key::TEXT, decrement::INT4)

newval = memcache\_decr(key::TEXT)
&
Если ключ существует и является целым числом, происходит уменьшение
его значения на указаное число (по умолчанию на единицу).
Возвращает целое число после уменьшения.\\

\hline

memcache\_delete(key::TEXT, hold\_timer::INTERVAL)

memcache\_delete(key::TEXT)

&
Удаляет указанный ключ. Если указать таймер, то ключ с таким же названием может
быть добавлен только после окончания таймера.\\

\hline

memcache\_flush\_all()

&
Очищает все данные на всех memcached серверах.\\

\hline

value = memcache\_get(key::TEXT)

&
Выбирает ключ из кэша. Возвращает NULL, если ключ не существует, иначе~--- текстовую строку.\\

\hline

memcache\_get\_multi(keys::TEXT[])

memcache\_get\_multi(keys::BYTEA[])

&
Получает массив ключей из кэша.
Возвращает список найденных записей в виде <<ключ=значение>>.\\

\hline

newval = memcache\_incr(key::TEXT, increment::INT4)

newval = memcache\_incr(key::TEXT)

&
Если ключ существует и является целым числом, происходит увеличение
его значения на указаное число (по умолчанию на единицу).
Возвращает целое число после увеличения.\\

\hline

memcache\_replace(key::TEXT, value::TEXT, expire::TIMESTAMPTZ)

memcache\_replace(key::TEXT, value::TEXT, expire::INTERVAL)

memcache\_replace(key::TEXT, value::TEXT)

&
Заменяет значение для существующего ключа.\\

\hline

memcache\_set(key::TEXT, value::TEXT, expire::TIMESTAMPTZ)

memcache\_set(key::TEXT, value::TEXT, expire::INTERVAL)

memcache\_set(key::TEXT, value::TEXT)

&
Создает ключ со значением. Если такой ключ существует~--- заменяет в нем значение на указаное.\\

\hline

stats = memcache\_stats()

&
Возвращает статистику по всем серверам memcached.\\

\hline
\end{tabular}
\end{table}

Посмотрим работу в СУБД данных функций. Для начала получим информацию о memcached серверах:

\begin{lstlisting}[language=SQL,label=lst:pgcache8,caption=Проверка memcache\_stats]
pgmemcache=# SELECT memcache_stats();
      memcache_stats
---------------------------

 Server: 127.0.0.1 (11211)
 pid: 1116
 uptime: 70
 time: 1289598098
 version: 1.4.5
 pointer_size: 32
 rusage_user: 0.0
 rusage_system: 0.24001
 curr_items: 0
 total_items: 0
 bytes: 0
 curr_connections: 5
 total_connections: 7
 connection_structures: 6
 cmd_get: 0
 cmd_set: 0
 get_hits: 0
 get_misses: 0
 evictions: 0
 bytes_read: 20
 bytes_written: 782
 limit_maxbytes: 67108864
 threads: 4

(1 row)
\end{lstlisting}

Теперь сохраним данные в memcached и попробуем их забрать:

\begin{lstlisting}[language=SQL,label=lst:pgcache9,caption=Проверка]
pgmemcache=# SELECT memcache_add('some_key', 'test_value');
 memcache_add
--------------
 t
(1 row)

pgmemcache=# SELECT memcache_get('some_key');
 memcache_get
--------------
 test_value
(1 row)

\end{lstlisting}

Можно также проверить работу счетчиков в memcached (данный функционал может пригодиться для создания последовательностей):

\begin{lstlisting}[language=SQL,label=lst:pgcache10,caption=Проверка]
pgmemcache=# SELECT memcache_add('some_seq', '10');
 memcache_add
--------------
 t
(1 row)

pgmemcache=# SELECT memcache_incr('some_seq');
 memcache_incr
---------------
            11
(1 row)

pgmemcache=# SELECT memcache_incr('some_seq');
 memcache_incr
---------------
            12
(1 row)

pgmemcache=# SELECT memcache_incr('some_seq', 10);
 memcache_incr
---------------
            22
(1 row)

pgmemcache=# SELECT memcache_decr('some_seq');
 memcache_decr
---------------
            21
(1 row)

pgmemcache=# SELECT memcache_decr('some_seq');
 memcache_decr
---------------
            20
(1 row)

pgmemcache=# SELECT memcache_decr('some_seq', 6);
 memcache_decr
---------------
            14
(1 row)

\end{lstlisting}

Для работы с pgmemcache лучше создать функции и, если требуется, активировать эти функции через триггеры.

Например, приложение кэширует зашифрованые пароли пользователей в memcached (для более быстрого доступа), и нам требуется обновлять информацию в кэше, если она изменяется в СУБД. Создаем функцию:

\begin{lstlisting}[language=SQL,label=lst:pgcache11,caption=Функция для обновления данных в кэше]
CREATE OR REPLACE FUNCTION auth_passwd_upd() RETURNS TRIGGER AS $$
	BEGIN
	IF OLD.passwd != NEW.passwd THEN
		PERFORM memcache_set('user_id_' || NEW.user_id || '_password', NEW.passwd);
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';
\end{lstlisting}

Активируем триггер для обновления таблицы пользователей:

\begin{lstlisting}[label=lst:pgcache12,caption=Триггер]
CREATE TRIGGER auth_passwd_upd_trg AFTER UPDATE ON passwd FOR EACH ROW EXECUTE PROCEDURE auth_passwd_upd();
\end{lstlisting}

Но данный пример транзакционно не безопасен~--- при отмене транзации кэш не вернется на старое значение. Поэтому лучше очищать старые данные:

\begin{lstlisting}[language=SQL,label=lst:pgcache13,caption=Очистка ключа в кэше]
CREATE OR REPLACE FUNCTION auth_passwd_upd() RETURNS TRIGGER AS $$
BEGIN
	IF OLD.passwd != NEW.passwd THEN
		PERFORM memcache_delete('user_id_' || NEW.user_id || '_password');
	END IF;
	RETURN NEW;
END;$$ LANGUAGE 'plpgsql';
\end{lstlisting}

Также нужен триггер на чистку кэша при удалении записи из СУБД:

\begin{lstlisting}[language=SQL,label=lst:pgcache14,caption=Триггер]
CREATE TRIGGER auth_passwd_del_trg AFTER DELETE ON passwd FOR EACH ROW EXECUTE PROCEDURE auth_passwd_upd();
\end{lstlisting}

Данный пример сделан для наглядности, а создавать кэш в memcached на кешированый пароль нового пользователя (или обновленного) лучше через приложение.


\subsection{Заключение}

PostgreSQL с помощью Pgmemcache библиотеки позволяет работать с memcached серверами, что может потребоваться в определенных случаях для кэширования данных напрямую с СУБД. Удобство данной библиотеки заключается в полном доступе к функциям memcached, но вот готовой реализации кэширование SQL запросов тут нет, и её придется дорабатывать вручную через функции и триггеры PostgreSQL.
